{{>partial_header}}
package runtime

import (
    "fmt"
    "github.com/bugsnag/bugsnag-go"
    "github.com/gorilla/mux"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "github.com/remitly/tiny-logger-go/log"
    "github.com/remitly/tiny-logger-go/log/zero"
    "github.com/spf13/pflag"
    "github.com/spf13/viper"
    "golang.org/x/net/context"
    "net/http"
    "os"
    "os/signal"
    "time"

    tinym "github.com/remitly/tiny-middleware-go/middlewares"
    "{{goModule}}/service"
)

const (
    configFile        = "CONFIG_FILE"
    envPrefix         = "ENV_PREFIX"
    allowEmptyEnvVar  = "ALLOW_EMPTY_ENV_VAR"
    port              = "PORT"
    rateLimit         = "RATE_LIMIT"
    rateLimitExceeded = "RATE_LIMIT_EXCEEDED"
    verbose           = "VERBOSE"
)

const (
    bugsnagAPIKey       = "BUGSNAG_API_KEY"
    bugsnagReleaseStage = "BUGSNAG_RELEASE_STAGE"
)


const (
    /*
        Hardcoded values come from infra.

        See: https://prometheus.int.remitly.com/config , where
        this is the relevant snippet that shows how prometheus is
        configured to scrape the services for their metrics:

        - job_name: apps
        metrics_path: /prometheusMetrics
        scheme: http
        ec2_sd_configs:
        - region: us-west-2
        port: 8351

        For additional references, see:

        * prometheus
            * https://godoc.org/github.com/prometheus/client_golang/prometheus
            * https://prometheus.io/docs/guides/go-application/
            * https://github.com/prometheus/client_golang/blob/master/prometheus/promhttp/http.go
        * go request routing
            * https://www.alexedwards.net/blog/a-recap-of-request-handling
            * https://www.alexedwards.net/blog/making-and-using-middleware
        * gorilla
            * https://github.com/gorilla/mux
    */
    prometheusMetricsPath = "/prometheusMetrics"
    prometheusMetricsPort = "8351"
)


const (
    readyCheckPath  = "/ready"
    aliveCheckPath  = "/alive"
    healthCheckPort = "8081"
)

type Bootstrap struct {
    // service name
    Name string

    // used for detecting service flapping
    ServiceStartedCounter prometheus.Counter

    // config
    ServiceConfig *viper.Viper

    // service http server
    ServiceHTTPServer *http.Server

    // health check server
    HealthCheckHTTPServer *http.Server

    // prometheus metrics server
    PrometheusMetricsHTTPServer *http.Server
}

func (bs Bootstrap) New() *Bootstrap {
    return &Bootstrap{}
}

func (bs *Bootstrap) ConfigureDefaults() *Bootstrap {
    serviceConfiguration := bs.serviceConfiguration()
    servicesStartedCounter := bs.serviceStartedCounter()
    serviceHTTPServer := bs.serviceHTTPServer(serviceConfiguration)
    prometheusHTTPServer := bs.prometheusHTTPServer()
    bs.configureBugsnag(serviceConfiguration)

    //healthCheckHTTPServer is set in main.go
    return &Bootstrap{
        ServiceStartedCounter:       servicesStartedCounter,
        ServiceConfig:               serviceConfiguration,
        ServiceHTTPServer:           serviceHTTPServer,
        PrometheusMetricsHTTPServer: prometheusHTTPServer,
    }
}

func (bs *Bootstrap) serviceConfiguration() *viper.Viper {
    // command line options for configuring the configuration system
    pflag.StringP(configFile, "c", "", "service config file")
    pflag.StringP(envPrefix, "e", "SVC", "environment prefix")
    pflag.StringP(allowEmptyEnvVar, "a", "true", "allow empty environment variables")

    pflag.StringP(port, "p", "8080", "service port")
    pflag.Float64P(rateLimit, "r", 1000.0, "rate limit (requests/second)")
    pflag.BoolP(verbose, "v", false, "verbose (debug level) logging")
    pflag.StringP(bugsnagAPIKey, "k", "", "bugsnag api key")
    pflag.StringP(bugsnagReleaseStage, "s", "preprod", "bugsnag api key")

    // load service specific configuration options
    customConfig := &service.Config{}
    customConfig.LoadApplicationSettings()

    // load pflags into viper
    pflag.Parse()
    err := viper.BindPFlags(pflag.CommandLine)
    if err != nil {
        panic(fmt.Errorf("fatal error binding pflag to viper: %s", err))
    }

    // create service config, bootstrapped from pflags
    svcConfig := viper.New()

    err = svcConfig.BindPFlags(pflag.CommandLine)
    if err != nil {
        panic(fmt.Errorf("fatal error binding pflag to svcConfig: %s", err))
    }

    // useful to understand passed in flags and env settings, etc.
    //svcConfig.Debug()

    if svcConfig.GetBool(verbose) {
        log.SetLogger(log.GetLogger().SetLevel(log.LoggingLevelDebug))
    }

    if viper.GetBool(allowEmptyEnvVar) {
        svcConfig.AutomaticEnv()
    }
    svcConfig.SetEnvPrefix(viper.GetString(envPrefix))
    svcConfig.AllowEmptyEnv(viper.GetBool(allowEmptyEnvVar))

    if viper.GetString(configFile) != "" {
        svcConfig.SetConfigFile(viper.GetString(configFile))
        err = svcConfig.ReadInConfig()
        if err != nil {
            panic(fmt.Errorf("fatal error config file: %s", err))
        }
    }
    return svcConfig
}

func (bs *Bootstrap) serviceStartedCounter() prometheus.Counter {
    return promauto.NewCounter(prometheus.CounterOpts{
    Name: fmt.Sprintf("%s_svc_started_total", bs.Name),
        Help: "The total number of times the service has started",
    })
}

func (bs *Bootstrap) serviceHTTPServer(config *viper.Viper) *http.Server {
    rateLimit := config.GetFloat64(rateLimit)
    rateLimitExceeded := config.GetString(rateLimitExceeded)
    var mw = tinym.NewTinyServiceMiddleware(bs.Name, rateLimit, rateLimitExceeded).Init()

    // common middleware is injected here
    port := config.GetString(port)
    return bs.ServiceHTTPServerWithMiddleware(mw.DecoratedHandler, port)
}

func (bs *Bootstrap) ServiceHTTPServerWithMiddleware(mw MiddleWare, port string) *http.Server {
    // configure the generated router with middleware
    router := NewRouter(mw)
    return &http.Server{
        Addr:         fmt.Sprintf("0.0.0.0:%s", port),
        WriteTimeout: time.Second * 15,
        ReadTimeout:  time.Second * 15,
        IdleTimeout:  time.Second * 60,
        Handler:      router,
    }
}

func (bs *Bootstrap) HealthCheckHTTPServerWithHandlers(ready http.Handler, alive http.Handler) *http.Server {
    // limit healthchecks to 10 requests per second
    rateLimit := 10.0
    var mw = tinym.NewTinyServiceMiddleware(fmt.Sprintf("%shealth", bs.Name), rateLimit, rateLimitExceeded).Init()

    r := mux.NewRouter()
    r.Handle(readyCheckPath, mw.DecoratedHandler(ready))
    r.Handle(aliveCheckPath, mw.DecoratedHandler(alive))
    return &http.Server{
        Addr:         fmt.Sprintf("0.0.0.0:%s", healthCheckPort),
        WriteTimeout: time.Second * 15,
        ReadTimeout:  time.Second * 15,
        IdleTimeout:  time.Second * 60,
        Handler:      r,
    }
}

func (bs *Bootstrap) prometheusHTTPServer() *http.Server {
    ph := promhttp.Handler()
    r := mux.NewRouter()
    r.Handle(prometheusMetricsPath, ph)
    return &http.Server{
        Addr:         fmt.Sprintf("0.0.0.0:%s", prometheusMetricsPort),
        WriteTimeout: time.Second * 15,
        ReadTimeout:  time.Second * 15,
        IdleTimeout:  time.Second * 60,
        Handler:      r,
    }
}

func (bs *Bootstrap) configureBugsnag(config *viper.Viper) {
    releaseStage := config.GetString(bugsnagReleaseStage)
    bugsnag.Configure(bugsnag.Configuration{
        ProjectPackages: []string{"main", bs.Name},
        ReleaseStage:    releaseStage,
        APIKey:          config.GetString(bugsnagAPIKey)})
}

func (bs *Bootstrap) launchHTTPServer(srv *http.Server) {
    // Run in a goroutine so that it doesn't block.
    go func() {
        if err := srv.ListenAndServe(); err != nil {
            log.Error(err)
        }
    }()

    err := srv.Handler.(*mux.Router).Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
        tmpl, err := route.GetPathTemplate()
        if err == nil {
            log.With("addr", srv.Addr).Infof("route: %s", tmpl)
        } else {
            log.With("addr", srv.Addr).With("err", err).Errorf("error walking router")
        }
        return nil
    })
    if err != nil {
        log.With("addr", srv.Addr).With("err", err).Errorf("error walking router")
    }
}

func (bs *Bootstrap) LaunchServer() {
    var wait time.Duration

    log.Debugf("%s starting with verbose logging enabled...", bs.Name)
    log.Infof("%s starting...", bs.Name)

    // prometheus metrics
    bs.launchHTTPServer(bs.PrometheusMetricsHTTPServer)

    // health check
    bs.launchHTTPServer(bs.HealthCheckHTTPServer)

    // service
    bs.launchHTTPServer(bs.ServiceHTTPServer)

    // increment the svc counter
    bs.ServiceStartedCounter.Inc()

    c := make(chan os.Signal, 1)
    // We'll accept graceful shutdowns when quit via SIGINT (Ctrl+C)
    // SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.
    signal.Notify(c, os.Interrupt)

    // Block until we receive our signal.
    <-c

    // Create a deadline to wait for.
    ctx, cancel := context.WithTimeout(context.Background(), wait)
    defer cancel()
    // Doesn't block if no connections, but will otherwise wait
    // until the timeout deadline.
    bs.ServiceHTTPServer.Shutdown(ctx)
    bs.PrometheusMetricsHTTPServer.Shutdown(ctx)
    bs.HealthCheckHTTPServer.Shutdown(ctx)
    // Optionally, you could run srv.Shutdown in a goroutine and block on
    // <-ctx.Done() if your application should wait for other services
    // to finalize based on context cancellation.
    log.Info("shutting down")
    os.Exit(0)
}

