{{>partial_header}}
package runtime

import (
    "fmt"
    "github.com/bugsnag/bugsnag-go"
    "github.com/gorilla/mux"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "github.com/remitly/tiny-logger-go/log"
    "golang.org/x/net/context"
    "net/http"
    "os"
    "os/signal"
    "time"

    tinym "github.com/remitly/tiny-middleware-go/middlewares"
    "{{goModule}}/service"
)

const (
    rateLimitExceeded = "RATE LIMIT EXCEEDED"
)


const (
    /*
        Hardcoded values come from infra.

        See: https://prometheus.int.remitly.com/config , where
        this is the relevant snippet that shows how prometheus is
        configured to scrape the services for their metrics:

        - job_name: apps
        metrics_path: /prometheusMetrics
        scheme: http
        ec2_sd_configs:
        - region: us-west-2
        port: 8351

        For additional references, see:

        * prometheus
            * https://godoc.org/github.com/prometheus/client_golang/prometheus
            * https://prometheus.io/docs/guides/go-application/
            * https://github.com/prometheus/client_golang/blob/master/prometheus/promhttp/http.go
        * go request routing
            * https://www.alexedwards.net/blog/a-recap-of-request-handling
            * https://www.alexedwards.net/blog/making-and-using-middleware
        * gorilla
            * https://github.com/gorilla/mux
    */
    prometheusMetricsPath = "/prometheusMetrics"
    prometheusMetricsPort = "8351"
)


const (
    readyCheckPath  = "/ready"
    aliveCheckPath  = "/alive"
    healthCheckPort = "8081"
)

type Bootstrap struct {
    // service name
    Name string

    // used for detecting service flapping
    ServiceStartedCounter prometheus.Counter

    // service http server
    ServiceHTTPServer *http.Server

    // health check server
    HealthCheckHTTPServer *http.Server

    // prometheus metrics server
    PrometheusMetricsHTTPServer *http.Server
}

func (bs Bootstrap) New(name string) *Bootstrap {
    return &Bootstrap{Name:name}
}

func (bs *Bootstrap) ConfigureDefaults() *Bootstrap {
    config := bs.serviceConfig()
    servicesStartedCounter := bs.serviceStartedCounter()
    serviceHTTPServer := bs.serviceHTTPServer(config)
    prometheusHTTPServer := bs.prometheusHTTPServer()
    bs.configureBugsnag(config)

    //healthCheckHTTPServer is set in main.go
    return &Bootstrap{
        Name:                        bs.Name,
        ServiceStartedCounter:       servicesStartedCounter,
        ServiceHTTPServer:           serviceHTTPServer,
        PrometheusMetricsHTTPServer: prometheusHTTPServer,
    }
}

func (bs *Bootstrap) serviceConfig() *service.Config {
    // load service specific configuration options
    service.Config{}.New().ConfigureServiceSettings()

    if service.GetConfig().Verbose {
        log.SetLogger(log.GetLogger().SetLevel(log.LoggingLevelDebug))
    }

    return service.GetConfig()
}

func (bs *Bootstrap) serviceStartedCounter() prometheus.Counter {
    return promauto.NewCounter(prometheus.CounterOpts{
    Name: fmt.Sprintf("%s_svc_started_total", bs.Name),
        Help: "The total number of times the service has started",
    })
}

func (bs *Bootstrap) serviceHTTPServer(c *service.Config) *http.Server {
    var mw = tinym.NewTinyServiceMiddleware(bs.Name, c.RateLimit, rateLimitExceeded).Init()

    // common middleware is injected here
    return bs.ServiceHTTPServerWithMiddleware(mw.DecoratedHandler, c.Port)
}


func (bs *Bootstrap) ServiceHTTPServerWithMiddleware(mw MiddleWare, port string) *http.Server {
    // configure the generated router with middleware
    router := NewRouter(mw)
    return &http.Server{
        Addr:         fmt.Sprintf("0.0.0.0:%s", port),
        WriteTimeout: time.Second * 15,
        ReadTimeout:  time.Second * 15,
        IdleTimeout:  time.Second * 60,
        Handler:      router,
    }
}

func (bs *Bootstrap) HealthCheckHTTPServerWithHandlers(ready http.Handler, alive http.Handler) *http.Server {
    // limit healthchecks to 10 requests per second
    rateLimit := 10.0
    var mw = tinym.NewTinyServiceMiddleware(fmt.Sprintf("%shealth", bs.Name), rateLimit, rateLimitExceeded).Init()

    r := mux.NewRouter()
    r.Handle(readyCheckPath, mw.DecoratedHandler(ready))
    r.Handle(aliveCheckPath, mw.DecoratedHandler(alive))
    return &http.Server{
        Addr:         fmt.Sprintf("0.0.0.0:%s", healthCheckPort),
        WriteTimeout: time.Second * 15,
        ReadTimeout:  time.Second * 15,
        IdleTimeout:  time.Second * 60,
        Handler:      r,
    }
}

func (bs *Bootstrap) prometheusHTTPServer() *http.Server {
    ph := promhttp.Handler()
    r := mux.NewRouter()
    r.Handle(prometheusMetricsPath, ph)
    return &http.Server{
        Addr:         fmt.Sprintf("0.0.0.0:%s", prometheusMetricsPort),
        WriteTimeout: time.Second * 15,
        ReadTimeout:  time.Second * 15,
        IdleTimeout:  time.Second * 60,
        Handler:      r,
    }
}

func (bs *Bootstrap) configureBugsnag(c *service.Config) {
    bugsnag.Configure(bugsnag.Configuration{
        ProjectPackages: []string{"main", bs.Name},
        ReleaseStage:    c.BugsnagReleaseStage,
        APIKey:          c.BugsnagAPIKey,
    })
}

func (bs *Bootstrap) launchHTTPServer(srv *http.Server) {
    // Run in a goroutine so that it doesn't block.
    go func() {
        if err := srv.ListenAndServe(); err != nil {
            log.Error(err)
        }
    }()

    err := srv.Handler.(*mux.Router).Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
        tmpl, err := route.GetPathTemplate()
        if err == nil {
            log.With("addr", srv.Addr).Infof("route: %s", tmpl)
        } else {
            log.With("addr", srv.Addr).With("err", err).Errorf("error walking router")
        }
        return nil
    })
    if err != nil {
        log.With("addr", srv.Addr).With("err", err).Errorf("error walking router")
    }
}

func (bs *Bootstrap) LaunchServer() {
    var wait time.Duration

    log.Debugf("%s starting with verbose logging enabled...", bs.Name)
    log.Infof("%s starting...", bs.Name)

    // prometheus metrics
    bs.launchHTTPServer(bs.PrometheusMetricsHTTPServer)

    // health check
    bs.launchHTTPServer(bs.HealthCheckHTTPServer)

    // service
    bs.launchHTTPServer(bs.ServiceHTTPServer)

    // increment the svc counter
    bs.ServiceStartedCounter.Inc()

    c := make(chan os.Signal, 1)
    // We'll accept graceful shutdowns when quit via SIGINT (Ctrl+C)
    // SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.
    signal.Notify(c, os.Interrupt)

    // Block until we receive our signal.
    <-c

    // Create a deadline to wait for.
    ctx, cancel := context.WithTimeout(context.Background(), wait)
    defer cancel()
    // Doesn't block if no connections, but will otherwise wait
    // until the timeout deadline.
    bs.ServiceHTTPServer.Shutdown(ctx)
    bs.PrometheusMetricsHTTPServer.Shutdown(ctx)
    bs.HealthCheckHTTPServer.Shutdown(ctx)
    // Optionally, you could run srv.Shutdown in a goroutine and block on
    // <-ctx.Done() if your application should wait for other services
    // to finalize based on context cancellation.
    log.Info("shutting down")
    os.Exit(0)
}

