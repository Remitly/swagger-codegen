{{>licenseInfo}}
package {{packageName}}

import com.bugsnag.Bugsnag
import com.remitly.ktor.BugsnagIntegration
import com.remitly.ktor.BugsnagIntegration.InstallBugsnag
import com.remitly.ktor.instrumentedServer
import com.remitly.ktor.MetricsIntegration
import com.remitly.ktor.TracingIntegration
import io.ktor.application.ApplicationStopping
import io.ktor.application.call
import io.ktor.application.install
import io.ktor.client.engine.apache.Apache
import io.ktor.client.HttpClient
import io.ktor.features.AutoHeadResponse
import io.ktor.features.ContentNegotiation
import io.ktor.features.DefaultHeaders
import io.ktor.features.StatusPages
import io.ktor.gson.GsonConverter
import io.ktor.http.ContentType
import io.ktor.http.HttpStatusCode
import io.ktor.response.respond
import io.ktor.routing.routing
import io.ktor.server.netty.Netty
import io.ktor.server.netty.NettyApplicationEngine
import com.natpryce.konfig.*
import com.natpryce.konfig.ConfigurationProperties.Companion.systemProperties

{{#generateApis}}
import {{apiPackage}}.*
{{/generateApis}}

{{#imports}}import {{import}}
{{/imports}}


object HTTP {
    val client = HttpClient(Apache)
}

object BSnag {
    val client = Bugsnag("YourKey").apply{
        // Configure your client
    }
}

// see https://www.kotlinresources.com/library/konfig/
object Config {
    const val serviceName = "{{artifactId}}"

    val service_port = Key("service.port", intType)
    val admin_port = Key("admin.port", intType)

    var config =
                systemProperties() overriding
                EnvironmentVariables() overriding
                ConfigurationMap("service.port" to "8080", "admin.port" to "9080")
}


object Application {

    @JvmStatic
    fun main(args: Array<String>) {

        val (cmdLine, argumentsList) = parseArgs(args,
            CommandLineOption(Config.service_port, "service-port", "p", "Port service runs on"),
            CommandLineOption(Config.admin_port, "admin-port", "a", "Port admin runs on")
        )

        Config.config = cmdLine overriding Config.config

        val ktor = instrumentedServer(
            factory = Netty,
            port = Config.config[Config.service_port],
            bugsnag = bugsnagIntegration(),
            tracing = tracingIntegration(),
            metrics = metricsIntegration(),
            configureApplicationEngine = NettyApplicationEngine.Configuration::instrumentServer
        ) {
            install(StatusPages) {
                exception<Throwable> {
                    call.respond(HttpStatusCode.InternalServerError)
                }
            }
            install(DefaultHeaders)
            install(ContentNegotiation) {
                register(ContentType.Application.Json, GsonConverter())
            }
            install(AutoHeadResponse)
            routing {
                {{#apiInfo}}
                {{#apis}}
                {{#operations}}
                {{classname}}()
                {{/operations}}
                {{/apis}}
                {{/apiInfo}}
            }

            environment.monitor.subscribe(ApplicationStopping) {
                HTTP.client.close()
            }
        }

        ktor.start(wait = true)
    }
}

fun NettyApplicationEngine.Configuration.instrumentServer() {
    // TODO
}

fun metricsIntegration(): MetricsIntegration {
    return MetricsIntegration.InstallMetrics(Config.config[Config.admin_port])
}

fun tracingIntegration(): TracingIntegration {
    return TracingIntegration.InstallTracing(Config.serviceName)
}

fun bugsnagIntegration(): BugsnagIntegration {
    return InstallBugsnag(BSnag.client)
}

