{{>licenseInfo}}
package {{packageName}}

import com.bugsnag.Bugsnag
import com.remitly.ktor.BugsnagIntegration
import com.remitly.ktor.BugsnagIntegration.InstallBugsnag
import com.remitly.ktor.instrumentedServer
import com.remitly.ktor.MetricsIntegration
import com.remitly.ktor.TracingIntegration
import io.ktor.application.ApplicationStopping
import io.ktor.application.call
import io.ktor.application.install
import io.ktor.client.engine.apache.Apache
import io.ktor.client.HttpClient
import io.ktor.features.AutoHeadResponse
import io.ktor.features.ContentNegotiation
import io.ktor.features.DefaultHeaders
import io.ktor.features.StatusPages
import io.ktor.gson.GsonConverter
import io.ktor.http.ContentType
import io.ktor.http.HttpStatusCode
import io.ktor.response.respond
import io.ktor.routing.routing
import io.ktor.server.netty.Netty
import io.ktor.server.netty.NettyApplicationEngine
import com.natpryce.konfig.*
import com.natpryce.konfig.ConfigurationProperties.Companion.systemProperties

{{#generateApis}}
import {{apiPackage}}.*
{{/generateApis}}

{{#imports}}import {{import}}
{{/imports}}


object HTTP {
    val client = HttpClient(Apache)
}

// see https://www.kotlinresources.com/library/konfig/
object Config {
    const val serviceName = "{{artifactId}}"
    lateinit var configuration: Configuration
}

class DefaultConfig(args: Array<String>){
    companion object {
        private const val configLogLevel = "log.level"
        private const val configServicePort = "service.port"
        private const val configAdminPort = "admin.port"
        private const val configBugsnagApiKey = "bugsnag.api.key"
        private const val configBugsnagReleaseStage = "bugsnag.release.stage"
        private const val configRateLimit = "rate.limit"

        val keyLogLevel = Key(configLogLevel, stringType)
        val keyServicePort = Key(configServicePort, intType)
        val keyAdminPort = Key(configAdminPort, intType)
        val keyBugsnagApiKey = Key(configBugsnagApiKey, stringType)
        val keyBugsnagReleaseStage = Key(configBugsnagReleaseStage, stringType)
        val keyRateLimit = Key(configRateLimit, doubleType)
    }

    private val defaultConfigLogLevel = "info"
    private val defaultConfigServicePort = 8080
    private val defaultConfigAdminPort = 9080
    private val defaultReleaseStage = "preprod"
    private val defaultConfigRateLimit = 1000.0


    private val cmdLineConfig : Configuration

    init {
        val (parsedCommandLineConfig, argumentsList) = parseArgs(args,
            CommandLineOption(keyLogLevel, "log-level", "l", "Logging level (default: $defaultConfigLogLevel)"),
            CommandLineOption(keyBugsnagApiKey, "bugsnag-api-key", "k", "Bugsnag API Key"),
            CommandLineOption(keyBugsnagReleaseStage, "bugsnag-release-stage", "s", "Bugsnag Release Stage (default: $defaultReleaseStage)"),
            CommandLineOption(keyServicePort, "port", "p", "Service port (default: $defaultConfigServicePort)"),
            CommandLineOption(keyAdminPort, "admin-port", "a", "Admin port (default: $defaultConfigAdminPort)"),
            CommandLineOption(keyRateLimit, "rate-limit", "r", "Maximum number of requests / second (default: $defaultConfigRateLimit)")
        )
        cmdLineConfig = parsedCommandLineConfig
    }


    val configuration =
        cmdLineConfig overriding
        systemProperties() overriding
        EnvironmentVariables() overriding
        ConfigurationMap(
            configLogLevel to defaultConfigLogLevel,
            configServicePort to defaultConfigServicePort.toString(),
            configAdminPort to defaultConfigAdminPort.toString(),
            configBugsnagApiKey to "",
            configBugsnagReleaseStage to defaultReleaseStage,
            configRateLimit to defaultConfigRateLimit.toString())

}

object Application {

    @JvmStatic
    fun main(args: Array<String>) {

        Config.configuration = DefaultConfig(args).configuration

        val ktor = instrumentedServer(
            factory = Netty,
            port = Config.configuration[DefaultConfig.keyServicePort],
            bugsnag = bugsnagIntegration(Config.configuration[DefaultConfig.keyBugsnagApiKey], Config.configuration[DefaultConfig.keyBugsnagReleaseStage]),
            tracing = tracingIntegration(),
            metrics = metricsIntegration(),
            configureApplicationEngine = NettyApplicationEngine.Configuration::instrumentServer
        ) {
            install(StatusPages) {
                exception<Throwable> {
                    call.respond(HttpStatusCode.InternalServerError)
                }
            }
            install(DefaultHeaders)
            install(ContentNegotiation) {
                register(ContentType.Application.Json, GsonConverter())
            }
            install(AutoHeadResponse)
            routing {
                {{#apiInfo}}
                {{#apis}}
                {{#operations}}
                {{classname}}()
                {{/operations}}
                {{/apis}}
                {{/apiInfo}}
            }

            environment.monitor.subscribe(ApplicationStopping) {
                HTTP.client.close()
            }
        }

        ktor.start(wait = true)
    }
}

fun NettyApplicationEngine.Configuration.instrumentServer() {
    // TODO
}

fun metricsIntegration(): MetricsIntegration {
    return MetricsIntegration.InstallMetrics(Config.configuration[DefaultConfig.keyAdminPort])
}

fun tracingIntegration(): TracingIntegration {
    return TracingIntegration.InstallTracing(Config.serviceName)
}

fun bugsnagIntegration(key: String, stage: String): BugsnagIntegration {
    val client = Bugsnag(key).apply{
            // Configure your client
    }
    return InstallBugsnag(client)
}

